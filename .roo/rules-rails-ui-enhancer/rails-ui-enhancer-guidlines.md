# AI GUIDELINES FOR RAILS UI/UX ENHANCEMENT (FRONTEND)

## I. CORE RESPONSIBILITY

*   Your primary goal is to enhance existing Rails views (`.html.erb`, partials) and implement frontend interactivity using the specified stack: ERB for structure, TailwindCSS v4 for styling, DaisyUI v5 for components, Turbo (Drive/Frames/Streams) for dynamic updates, and Stimulus for client-side JS interactions.
*   You MUST NOT modify backend code (Models, Controllers (except maybe `render turbo_stream`), Routes, Migrations, Jobs, backend tests). Focus solely on the presentation layer.
*   Follow all instructions precisely and adhere strictly to these guidelines.

## II. GENERAL CODING & SYNTAX

*   **HTML:** Write clean, semantic HTML5.
*   **ERB:** Use ERB (`<%= %>`, `<% %>`) for embedding Ruby logic *for presentation purposes only*.
*   **CSS:** Apply styles *only* via Tailwind/DaisyUI utility classes within HTML tags. **Prohibited:** Do not write custom CSS rules in `.css` files or `<style>` tags.
*   **JavaScript:** Write Stimulus controllers (`app/javascript/controllers/`) when necessary. Use Import Maps for dependencies.
*   **Naming Conventions:** Follow `snake_case` for ERB variables/helpers, `CamelCase` for Stimulus controller filenames, standard HTML/CSS/JS conventions.
*   **Formatting:** Ensure clean HTML/ERB/JS formatting. Adhere to RuboCop standards for any Ruby in ERB.

## III. DIRECTORY STRUCTURE & FILE PLACEMENT

*   Modify/Create files primarily in:
    *   Views: `app/views/{resource_name}/`
    *   Shared Partials: `app/views/shared/`
    *   Stimulus Controllers: `app/javascript/controllers/`
    *   Tailwind Config: `config/tailwind.config.js` (if modification needed)
    *   Tailwind Entrypoint: `app/assets/tailwind/application.css` (usually no edits needed)
    *   Import Map: `config/importmap.rb` (if pinning new JS)

## IV. VIEWS (`app/views/`) & HELPERS (`app/helpers/`) - Frontend Focus

*   **Semantic HTML:** Prioritize meaningful HTML5 elements (`<nav>`, `<main>`, `<button>`, etc.).
*   **ERB for Presentation:** Use ERB to render dynamic content, iterate over collections for display, and conditionally show elements.
*   **Logic-Free Views:** Keep complex data manipulation or business logic out of views. Use data prepared by the controller or call simple Helper methods.
*   **Partials:** Use partials extensively for reusable UI components (cards, navigation elements, form sections). Pass data *explicitly* using `locals:`.
*   **Helpers:** Create helpers (`app/helpers/`) for *presentation logic only* (e.g., complex conditional CSS classes, formatting data specifically for display, generating complex HTML snippets reused in views). Use built-in helpers (`link_to`, `button_to`, `image_tag`, `number_to_currency`, etc.). Use specific Turbo helpers (`turbo_frame_tag`, `turbo_stream_from`, etc.) as needed.
*   **Forms (`form_with`):** Style forms using Tailwind/DaisyUI classes applied within the `form_with` block and its helpers (`form.text_field :name, class: 'input...'`). Ensure accessibility (use `form.label` for every input). Use collection helpers (`form.collection_select`) for selects/radios/checkboxes based on data. Handle nested forms (`fields_for`) styling.
*   **Icons:** Use the `icon` helper from `rails_icons` gem, applying classes for styling: `<%= icon "check", class: "w-5 h-5 text-green-500" %>`. **Prohibited:** No raw SVG in views.

## V. STYLING (TailwindCSS v4 & DaisyUI v5)

*   **Utility-First:** Apply styles directly via classes in HTML tags.
*   **Tailwind Config:** Use the central `tailwind.config.js`.
*   **DaisyUI Components:** Use DaisyUI classes (`btn`, `card`, `modal`, etc.) for base components.
*   **Customize with Tailwind:** Combine DaisyUI and Tailwind classes (`<div class="card bg-base-100 shadow-xl p-4 mt-2">`).
*   **Responsive Design:** Use Tailwind's responsive modifiers (`sm:`, `md:`, `lg:`) extensively. Aim for mobile-first.
*   **States:** Style interaction states (hover, focus, disabled) using Tailwind/DaisyUI variants (`hover:bg-blue-600`, `btn-disabled`, `:focus-visible`).

## VI. JAVASCRIPT (Hotwire: Turbo & Stimulus)

### A. Turbo Overview & Core Concepts

*   **Goal:** Use Hotwire (Turbo + Stimulus) for dynamic, SPA-like user experiences without needing a heavy client-side framework. Enhance server-rendered HTML.
*   **Turbo Helpers:** Leverage helpers provided by the `turbo-rails` gem (`turbo_frame_tag`, `turbo_stream_from`, `dom_id`, `turbo_stream` object, etc.).
*   **Non-GET Actions:** For links/buttons performing non-GET actions (DELETE, PATCH, POST), prefer using actual `<form>` elements (often generated by `button_to`). If using `link_to`, add the `data: { turbo_method: :delete }` attribute.
    ```erb
    <%# Good: Using button_to for non-GET actions %>
    <%= button_to "Delete Post", post_path(@post), method: :delete, data: { turbo_confirm: "Are you sure?" } %>

    <%# Alternative: link_to for non-GET (use cautiously) %>
    <%= link_to "Delete", post_path(@post), data: { turbo_method: :delete, turbo_confirm: "Are you sure?" } %>
    ```
*   **Confirmation Dialogs:** Use `data: { turbo_confirm: "Your message" }` within Rails helpers (`link_to`, `button_to`, `form_with`) to trigger a native browser confirmation dialog before proceeding.
    ```erb
    <%= form_with(model: @post, data: { turbo_confirm: "Save changes?" }) do |form| %>
      <%# ... form fields ... %>
      <%= form.submit %>
    <% end %>
    ```
*   **View Transitions:** Enable smooth, native browser page transitions between visits by adding `<meta name="view-transition" content="same-origin">` to the `<head>` of your application layout.

### B. Turbo Drive

*   **Function:** Handles full page navigation and form submissions seamlessly, replacing only the `<body>` and merging the `<head>`, improving perceived performance. Generally works automatically.
*   **Progress Bar:** Shows automatically during navigation; can be styled via CSS.

### C. Turbo Frames

*   **Purpose:** Use `turbo_frame_tag` to isolate sections of a page for independent updates or lazy loading, without affecting the rest of the page content.
*   **Defining Frames:** Use the `turbo_frame_tag` helper, passing a unique DOM ID (often derived from a model using `dom_id`).
    ```erb
    <%# Wrapping a resource display %>
    <%= turbo_frame_tag dom_id(@message) do %>
      <h1><%= @message.title %></h1>
      <p><%= @message.content %></p>
      <%= link_to "Edit", edit_message_path(@message) %>
    <% end %>

    <%# Wrapping a form %>
    <%= turbo_frame_tag "new_message_form" do %>
      <%= render "form", message: Message.new %>
    <% end %>
    ```
*   **Frame Navigation:** Links and forms *inside* a frame target that frame by default. The server response *must* include a matching `<turbo-frame>` tag with the same ID for the update to succeed.
*   **Eager/Lazy Loading:**
    *   Use the `src:` option in `turbo_frame_tag` to load content immediately upon page load (eager).
    *   Add `loading: :lazy` along with `src:` to defer loading until the frame is visible in the viewport (lazy).
    ```erb
    <%# Eager Loading Frame %>
    <%= turbo_frame_tag "user_stats", src: user_stats_path(@user) do %>
      <p>Loading stats...</p>
    <% end %>

    <%# Lazy Loading Frame %>
    <%= turbo_frame_tag "user_comments", src: user_comments_path(@user), loading: :lazy do %>
      <p>Loading comments...</p>
    <% end %>
    ```
*   **Targeting Navigation Outside/Between Frames:**
    *   To make navigation inside a frame target the *entire page* (break out of the frame), add `data: { turbo_frame: "_top" }` to the link/button/form helper.
    *   To target a *different* frame, use `data: { turbo_frame: "other_frame_id" }`.
    *   To make *all* navigation within a frame target the full page by default, add `target: "_top"` to the `turbo_frame_tag` itself.
    ```erb
    <%= turbo_frame_tag "sidebar", target: "_top" do %>
      <%= link_to "Dashboard", dashboard_path %> <%# Targets _top due to frame default %>
    <% end %>

    <%= turbo_frame_tag "content" do %>
      <%= link_to "View Full Profile", profile_path, data: { turbo_frame: "_top" } %>
      <%= link_to "Open Settings", "#", data: { turbo_frame: "modal_frame" } %> <%# Targets modal_frame %>
    <% end %>
    ```
*   **Updating Browser History:** To make frame navigation update the browser's URL and history (like a full page visit), add `data: { turbo_action: "advance" }` (pushes new state) or `data: { turbo_action: "replace" }` (replaces current state) to the `turbo_frame_tag` or the triggering element's helper.
    ```erb
    <%# Frame for pagination, updates URL %>
    <%= turbo_frame_tag dom_id(@items_page), data: { turbo_action: "advance" } do %>
      <%# Items list %>
      <%= link_to "Next Page", items_path(page: @items_page.next_param) %>
    <% end %>
    ```

### D. Turbo Streams

*   **Purpose:** Use for targeted, asynchronous DOM manipulations (CRUD updates, real-time notifications, etc.). Allows multiple independent parts of the page to be updated from a single server response.
*   **Stream Actions:** Common actions are `append`, `prepend`, `replace`, `update`, `remove`, `before`, `after`.
*   **Responding with Streams:**
    *   Configure controller actions to `respond_to :turbo_stream`.
    *   In the controller action, use the `turbo_stream` object with action methods, typically rendering partials:
        ```ruby
        # In controller
        format.turbo_stream do
          render turbo_stream: turbo_stream.replace(@product, partial: "products/product", locals: { product: @product })
        end
        # Or multiple actions:
        format.turbo_stream do
          render turbo_stream: [
            turbo_stream.replace(@product), # Implicitly renders _product partial
            turbo_stream.update("product_count", @products.count)
          ]
        end
        ```
    *   Alternatively, create a `.turbo_stream.erb` view template containing multiple `<%= turbo_stream.* %>` helper calls.
        ```erb
        <%# app/views/products/create.turbo_stream.erb %>
        <%= turbo_stream.append "products_list", @product %> <%# Renders _product partial %>
        <%= turbo_stream.update "new_product_form", partial: "products/form", locals: { product: Product.new } %>
        <%= turbo_stream.prepend "flash_messages", partial: "shared/flash", locals: { message: "Product created!" } %>
        ```
*   **Targeting:** The `turbo_stream` helpers take a DOM ID (String or an object responding to `to_key` like an AR record, which uses `dom_id`) as the target. Use the `target:` keyword argument with a CSS selector for multiple targets (`turbo_stream.remove(target: ".archived")`).
*   **Morphing:** Use `method: :morph` option with `replace` and `update` actions for smoother DOM updates using morphdom.
*   **GET Requests with Streams:** If a GET request needs to respond with Turbo Streams (less common), add `data: { turbo_stream: true }` to the `link_to` or `form_with method: :get` helper.
*   **Reusing Partials:** Render the *same* partials in Stream responses as you use for regular HTML responses to keep UI consistent and DRY. Ensure partials are granular enough for targeted updates.
*   **Broadcasting (Real-time):** Use model callbacks (`after_create_commit`, etc.) with broadcasting helpers (`broadcast_append_to`, `broadcast_replace_later_to`, etc.) to push Stream updates via Action Cable to subscribed clients. Use `<%= turbo_stream_from @channel %>` in views to subscribe. *(Setup requires coordination with backend)*.

### E. Stimulus

*   **Purpose:** Use *sparingly* for client-side behaviors beyond Turbo/CSS capabilities (complex UI state, third-party JS integration, client-side validation enhancements, animations, drag-and-drop).
*   **Generator:** Use `bin/rails generate stimulus controller_name` to create controller files.
*   **Naming and Identifiers:**
    *   Filename: `[identifier]_controller.js` (underscores, e.g., `date_picker_controller.js`). Use subdirectories for namespacing (`forms/input_validator_controller.js`).
    *   Identifier Mapping: `clipboard_controller.js` -> `clipboard`; `date_picker_controller.js` -> `date-picker`; `forms/input_validator_controller.js` -> `forms--input-validator`.
*   **Connecting to HTML:** Use `data-controller="identifier another-identifier"` in ERB.
    ```erb
    <div data-controller="clipboard list-item">
      <%# Controller scope %>
    </div>
    ```
*   **Scope & Properties:** Scope includes element and descendants. Access element via `this.element`, application via `this.application`, identifier via `this.identifier`.
*   **Lifecycle Callbacks:**
    *   `initialize()`: Called once on creation (before DOM connection).
    *   `connect()`: Called each time element connects to DOM. Use for DOM-dependent setup, adding listeners.
    *   `disconnect()`: Called each time element disconnects. **Crucial for cleanup** (remove listeners, clear timers/intervals, destroy libraries) to prevent memory leaks.
    *   `[name]TargetConnected(element)` / `[name]TargetDisconnected(element)`: Called when specific targets connect/disconnect.
        ```javascript
        // Example cleanup in disconnect
        disconnect() {
          if (this.resizeObserver) {
            this.resizeObserver.disconnect();
          }
          window.removeEventListener("scroll", this.boundScrollHandler);
        }
        ```
*   **Actions:** Connect DOM events to controller methods.
    *   Descriptor: `data-action="[event]->[identifier]#[method]"` (e.g., `click->clipboard#copy`). Event shorthand allowed (`click` for button, `input` for input, `submit` for form).
    *   Method Signature: Receives `event` object (`copy(event) { ... }`). Use `event.preventDefault()`, `event.target`, etc.
    *   Multiple Actions: Space-separated descriptors.
    *   Global Events: Use `@window` or `@document` (e.g., `keydown.esc@window->modal#close`).
    *   Keyboard Filters: `.keyName` (e.g., `keydown.enter`, `keyup.shift+arrowup`).
    *   Action Options: `:once`, `:passive`, `:capture`, `:prevent`, `:stop`, `:self` (e.g., `submit->form#save:prevent`).
    *   Action Parameters: Pass data via `data-[identifier]-[param]-param="value"`. Access in method via `event.params` or destructuring `{ params }` or `{ params: { specificParam } }`. Types are auto-cast.
        ```erb
        <button data-action="item#upvote" data-item-id-param="123">Upvote</button>
        ```
        ```javascript
        upvote({ params: { id } }) { console.log(id); /* 123 (Number) */ }
        ```
*   **Targets:** Reference specific elements within the scope.
    *   Definition: `static targets = ["slide", "currentItem"]` (`camelCase`).
    *   HTML Connection: `data-[identifier]-target="name"` (`kebab-case`, e.g., `data-slideshow-target="current-item"`).
    *   Properties: `this.[name]Target` (first element, throws if missing), `this.[name]Targets` (all elements array), `this.has[Name]Target` (boolean check - **use for optional targets**).
*   **Values API:** Manage state reflected in `data-*` attributes.
    *   Definition: `static values = { index: Number, url: String, enabled: { type: Boolean, default: true } }`. Types: `String`, `Number`, `Boolean`, `Array`, `Object`.
    *   HTML Connection: `data-[identifier]-[name]-value="..."` (`kebab-case`, e.g., `data-slideshow-index-value="0"`). Use JSON for Array/Object.
    *   Properties: `this.[name]Value` (getter), `this.[name]Value = newValue` (setter, updates attribute), `this.has[Name]Value` (boolean check).
    *   Change Callbacks: `[name]ValueChanged(newValue, previousValue)` method is called automatically on init and value change.
*   **CSS Classes API:** Manage CSS classes programmatically.
    *   Definition: `static classes = ["loading", "error"]` (`camelCase`).
    *   HTML Connection: `data-[identifier]-[name]-class="actual-css-class another-class"` (`kebab-case`, e.g., `data-loader-loading-class="opacity-50 cursor-wait"`).
    *   Properties: `this.[name]Class` (first class string), `this.[name]Classes` (array of classes), `this.has[Name]Class` (boolean check).
    *   Usage: Use with `element.classList.add/remove/toggle(...this.[name]Classes)`.
*   **Progressive Enhancement:** Design for resilience (works without JS where possible). Use Stimulus to enhance. Use the CSS hiding pattern (hide elements via CSS, use Stimulus `connect()` to check feature support, add a class via Classes API to reveal).

## VII. ASSETS (Propshaft & Import Maps)

*   Assume Propshaft handles asset serving in production.
*   Manage JS via Import Maps (`config/importmap.rb`). Pin Stimulus controllers.

## VIII. ACCESSIBILITY (A11y)

*   **Semantic HTML:** Use correct elements for inherent accessibility.
*   **ARIA:** Use ARIA attributes (`role`, `aria-*`) only when necessary to supplement semantics (e.g., for dynamic regions updated by Turbo Streams/Stimulus).
*   **Keyboard Navigation:** Ensure all interactive elements are focusable and usable via keyboard. Style focus states clearly (`:focus`, `:focus-visible`).
*   **Color Contrast:** Ensure sufficient contrast per WCAG guidelines.
*   **Alt Text:** Provide meaningful `alt` text for informative images; use `alt=""` for decorative ones.
*   **Loading States:** Use `aria-busy="true"` on elements being updated (Turbo often handles this). Announce changes via ARIA live regions if necessary.

## IX. USER FEEDBACK & INTERACTION STATES

*   **Loading:** Use Turbo progress bar, DaisyUI spinners/skeletons within Turbo Frames or Stimulus-controlled areas. Use `disable_with` (`data-turbo-submits-with`) on buttons/forms.
*   **Disabled:** Apply `disabled` attribute and styles (`opacity-50`, `cursor-not-allowed`, `btn-disabled`).
*   **Success/Error:** Style Rails flash messages consistently (often rendered in a dedicated partial/frame/stream). Ensure validation errors are clearly displayed near fields. Provide visual feedback for Stimulus actions (e.g., change button text on copy).

## X. PROHIBITED ACTIONS

*   Do not write backend code (Models, Controllers, Routes, Migrations).
*   Do not write custom CSS rules outside of Tailwind utilities.
*   Do not introduce complex JS frameworks or build tools (stick to Hotwire/Import Maps).
*   Do not embed raw SVG; use the `icon` helper.
*   Do not deviate from the Hotwire/Tailwind/DaisyUI stack.